# Farada
![main](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/main.gif)  
Farada is short for Fast random data Generator. And it does exactly what it says.
  - Create random data with blazing fast performance
    - By using compiled LINQ expressions instead of reflection
    - By supporting and encouraging cpu-parallelization
  - Fill any type in a fully configurable way
    - No configuration needed at all to fill basic types, and complex types containing basic types. 
    - Fluent, type safe configuration API

## Installation Guide
In order to use Farad you just need to search it in nuget  
![nuget00](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/nuget00.png)

And then install the latest package:  
![nuget01](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/nuget01.png)
  
## Features
The simplest thing you can do with Farada, is just create some random data. Lets start with **integers**:  
![integers](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/createmanyint.png)  
![integersresult](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/createmanyint.gif)  

Or **strings**:  
![strings](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/createmanystring.png)  
![stringsresult](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/createmanystring.gif)  

But maybe you just want to create **cats**:  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/catclass.png)  
![cats](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/createcats.png)  
![catsresult](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/cats.gif)  
_Its as simple as that_

But wait.. the age. Cats don't get that old (which is a pitty) so lets correct that.  
![specificcats](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/createspecificcats.png)  
![specificcatsresult](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/specificcats.gif)  
Looks much bettet. Now all cats are between 0 and 20 years old.

Hmm but what about **immutable cats**:  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/immutablecat.png)  
They **work out of the box**, without any changes required.

But now we start asking questions like: What if our cats want to get **emails**?  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/catwithemail.png)  
Now lets Farada work some magic.  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/catmails.gif)  
Tada. Farada notices the EmailAddress attribute (from System.DataAnnotions) and fills the property accordingly.  
Now we have some happy cats. :>

But what if we want to name all cats **Sir <something>**... after the age of 10, because they have proven to be true MVPs?  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/sircats.png)  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/sircats.gif)  
Again, it's as simple as that. By calling GetPreviousValue on the context, we can retrieve the value generated by  
a previous value generator (in this case: the default value provider for strings). 

Now we are going for the full 360. We want to fill a property according to some **custom attribute**, defined by ourselfs.  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/customattributeskitty.png)  
So as you can see, the UseConstant attribute is defined by us. Now we want to put the value of the attribute in the name property.  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/customattributeskittyconfig.png)  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/kittycats.gif)  
Thats how it is done. now all our cats are named "Kitty".\ Allow Multiple Attributes can be accessed through ctx.Attributes (list).  

Now we will go over the top by creating no less than 10 million kittys. Woah won't that blow our pc?  
Lets assume we have configured our C# project with server gc:  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/recommendedgcsettings.png)  
This is btw recommended for Farada (because client GC collects more often, and thus thampers with generation performance).  
So lets create 10 milllion cats:  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/10millioncats.png)  
_It's as simple as that._  
But what about the performance? Well creating **10 000 000 Cats** - takes just **5.5244841 seconds** (_so under 6s_), 
on my PC with a 3.7GHZ quadcore from Intel. 

## Advanced Features
Ok now at the end we will look at some of the more advanced features (but we are barely scratching the surface).  
First off, we look at how Farada handels **derived types**.  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/catdoge.png)  
A simple hierachy where cat and dog derive from animal. Now lets configure Farada:  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/catdogeconfig.png)  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/catdogefight.gif)  
We define Age, and Name just for Animal, which also works for all subtypes automatically. However for cat name we add some text.  
This can be done by using the previous value (the provider for Animal.Name in this case) and add some text (could also be random).  

Ok the next feature on our list is not using the **default config** from Farada.  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/usedefaultsfalse.png)  
Now we have now value Providers at all, not for creating strings, not even for instantiating a class.  
So we will get an **exception** like this:  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/missingvalueproviderforcat.png)  
Farada is advising us to define a value provider for the type <Cat>. So let's do it:  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/missingvalueproviderforage.png)  
Now we defined that our cats are created by the default instance provider of farada. 
>If you want to create your own instance provider you can look through the source code on GitHub.  
>Note however the the DefaultInstanceProvider of Farada supports immutable types, and is therefore rather complex.

So we get another **exception**.  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/missingvalueproviderforageex.png)  
This time advising us to provide a value provider of the Property Cat.Age (which is an integer).  
Let's do that:  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/usedefaultsfalseworkingconfig.png)  
Now that we provided a value provider for int and string (the types of the cats properties) the creation of Cats works again.  
So as you can see, Farada tells you exactly what's missing, so it's super easy to add your own value providers for basic types.  

Other things you can do with Farada is **modifying the instances**, that are created by the DefaultInstanceProvider.  
For example if you want to make some of the instances null.  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/nullmodifier.png)  
You can just use Faradas builtin NullModifier, or create a custom instance modifier.  
Note: This modifier gets all instances, not depending on the type.

Last but not least you can **exchange the random generator** used by all value providers:  
![cat](https://raw.githubusercontent.com/Inspyro/Data/master/Farada/images/randomwithseed.png)  
In this example we use Faradas default Random (wrapper of System.Random) but add a seed, so we will get the same values everytime we re-run the program. 
This is super useful for unit tests. You can also implement your custom IRandom implementation (interface provided by farada), or just use a Fake framework . 

## Final notes
Thas it for now. But there is much more to be explored, such as:
 - Interface support
 - Advanced Value providers (using the ctx.Advanced properties) - e.g. the DefaultInstanceValueProvider
 - Member Extensions Service (UseMemberExtensionService) for extending Faradas reflection (like TypeProviders).
 - Parameter to Property conversion (UseParameterToPropertyConversion) for changing the behaviour, how args are matched to properties in immutable classes
 - AutoFill handling (which instances are filled by the value provider, which by farada) 
 - Filling depth (on cyclic dependencies)
 - And of course: **Farada.Evolution**. An evolutionary approach to create meaningful data. 

